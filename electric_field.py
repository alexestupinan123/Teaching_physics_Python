# -*- coding: utf-8 -*-
"""Electric Field.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sqTyL_Xd60uz8GGo-p1KAV1K-QtI7iNr
"""

#-*- coding: utf-8 -*-
"""
Created on Tue Feb 13 09:02:47 2018

@author: Daniel Triana, Karen Cristancho, Alex EStupinan. 
"""

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

nq = input('Ingrese el número de cargas n = ')
rp = np.array(input('Ingrese el vector al punto p, coordenadas (x,y,z) y en [m] = '))

def field_punctual_charges(rp, n, ke=9e9):
    i = 0
    q = np.zeros(n)
    rq = np.zeros((n, 3))
    ri = np.zeros((n, 3))
    mag_ri = np.zeros(n)
    uni_ri = np.zeros((n, 3))
    vec_E = np.zeros((n, 3))
    mag_Ep = 0.0
    if n < 1:
        print('1 es el mínimo número de cargas para producir campo eléctrico')
        q = np.zeros(n)
        rq = np.zeros((n, 3))
        ri = np.zeros((n, 3))
        mag_ri = np.zeros(n)
        uni_ri = np.zeros((n, 3))
        vec_E = np.zeros((n, 3))
        vec_Ep = np.zeros(3)
        mag_Ep = 0.0
    else:
        fig = plt.figure()
        ax = fig.gca(projection='3d')
        ax.scatter3D(rp[0], rp[1], rp[2], c='k', s=50)
        ax.quiver3D([0], [0], [0], rp[0], rp[1], rp[2], pivot='tail', length = 1.0, arrow_length_ratio=0.1, color='g')
        while i < n:
            #input individual charge value
            #q[i] = input('Ingrese el valor de la carga numero '+str(i+1)+' en Coulomb = ')
            q[i] = 1e-9
            #spatial position of charges
            #rq[i] = input('Ingrese el vector posicion (x,y,z) de la carga numero '+str(i+1)+' = ')
            phi = i*2*np.pi/n
            rq[i] = [np.cos(phi), np.sin(phi), 0]
            ax.quiver3D([0], [0], [0], rq[i][0], rq[i][1], rq[i][2], pivot='tail', length = 1.0, arrow_length_ratio=0.1) #length = np.sqrt(rq[i][0]**2+rq[i][1]**2+rq[i][2]**2)
            if q[i]>0:
                co = 'r' #carga positiva
            else:
                co = 'b' #carga negativa
            ax.scatter3D(rq[i][0], rq[i][1], rq[i][2], c=co, s=100)
            ri[i] = rp - rq[i]
            mag_ri[i] = np.sqrt(sum(ri[i]**2))
            ax.quiver3D(rq[i][0], rq[i][1], rq[i][2], ri[i][0], ri[i][1], ri[i][2], pivot='tail', length = 1.0, arrow_length_ratio=0.1, color='m') #length = mag_ri[i]
            uni_ri[i] = ri[i]/mag_ri[i]
            vec_E[i] = (ke*q[i]/mag_ri[i]**2)*uni_ri[i]
            i += 1
        vec_Ep = np.array([sum(vec_E[:,0]), sum(vec_E[:,1]), sum(vec_E[:,2])])
        ax.quiver3D(rp[0], rp[1], rp[2], vec_Ep[0], vec_Ep[1], vec_Ep[2], pivot='tail', length = 1, color='c', arrow_length_ratio=0.3, normalize=True)
        mag_Ep = np.sqrt(sum(vec_Ep**2))
        
        mag_rp = np.sqrt(rp[0]**2+rp[1]**2+rp[2]**2)
        arrows = np.array([[0, 0, 0, 2*mag_rp, 0, 0], [0, 0, 0, 0, 2*mag_rp, 0], [0, 0, 0, 0, 0, 2*mag_rp]])
        X, Y, Z, U, V, W = zip(*arrows)
        ax.quiver3D(X, Y, Z, U, V, W, pivot='tail', length = 1.0, color='k', arrow_length_ratio=0.1) #length = 2*mag_rp
        ax.set_xlim([-rq.max()-rp.max(), rq.max()+rp.max()])
        ax.set_ylim([-rq.max()-rp.max(), rq.max()+rp.max()])
        ax.set_zlim([-rq.max()-rp.max(), rq.max()+rp.max()])
        ax.set_xlabel('x')
        ax.set_ylabel('y')
        ax.set_zlabel('z')
        ax.set_title('$E_p = $'+str(vec_Ep[0])+' $i$ +'+str(vec_Ep[1])+' $j$ +'+str(vec_Ep[2])+' $k$'+str( )+' $[V/m]$')
        plt.show()
    return q, rq, ri, mag_ri, uni_ri, vec_E, vec_Ep, mag_Ep

q, rq, ri, mag_ri, uni_ri, vec_E, vec_Ep, mag_Ep = field_punctual_charges(rp, n=nq)

print'\n', 'Ep = ', vec_Ep[0],'i', vec_Ep[1],'j', vec_Ep[2],'k', ' [V/m]','\n', 'Ep = ', mag_Ep, ' [V/m]'



#-*- coding: utf-8 -*-
"""
Created on Tue Feb 13 09:02:47 2018

@author: Silvi
"""

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

nq = int(input('Ingrese el numero de cargas n = '))
rp = np.array([float(input("Ingrese el vector al punto p, coordenadas (x,y,z) y en [m]")) for l in range(3)])

def field_punctual_charges(rp, n, ke=9e9):
    i = 0
    q = np.zeros(n)
    rq = np.zeros((n, 3))
    ri = np.zeros((n, 3))
    mag_ri = np.zeros(n)
    uni_ri = np.zeros((n, 3))
    vec_E = np.zeros((n, 3))
    mag_Ep = 0.0
    if n < 1:
        print('1 es el mínimo número de cargas para producir campo eléctrico')
        q = np.zeros(n)
        rq = np.zeros((n, 3))
        ri = np.zeros((n, 3))
        mag_ri = np.zeros(n)
        uni_ri = np.zeros((n, 3))
        vec_E = np.zeros((n, 3))
        vec_Ep = np.zeros(3)
        mag_Ep = 0.0
    else:
        fig = plt.figure()
        ax = fig.gca(projection='3d')
        ax.scatter3D(rp[0], rp[1], rp[2], c='k', s=50)
        ax.quiver3D([0], [0], [0], rp[0], rp[1], rp[2], pivot='tail', length = 1.0, arrow_length_ratio=0.1, color='g')
        while i < n:
            #input individual charge value
            qs = 1e-9 #np.array([1])
            q[i] = float(input("Ingrese el valor de la carga numero "+str(i+1)+" en Coulomb = "))
            #q[i] = 1e-9
            #spatial position of charges
            rq[i] = np.array([float(input('Ingrese el vector posicion (x,y,z) de la carga numero '+str(i+1)+' = ')) for l in range(3)])
            #phi = i*2*np.pi/n
            #rq[i] = [np.cos(phi), np.sin(phi), 0]
            ax.quiver3D([0], [0], [0], rq[i][0], rq[i][1], rq[i][2], pivot='tail', length = 1.0, arrow_length_ratio=0.1) #length = np.sqrt(rq[i][0]**2+rq[i][1]**2+rq[i][2]**2)
            if q[i]>0:
                co = 'r' #carga positiva
            else:
                co = 'b' #carga negativa
            ax.scatter3D(rq[i][0], rq[i][1], rq[i][2], c=co, s=100)
            ri[i] = rp - rq[i]
            mag_ri[i] = np.sqrt(sum(ri[i]**2))
            ax.quiver3D(rq[i][0], rq[i][1], rq[i][2], ri[i][0], ri[i][1], ri[i][2], pivot='tail', length = 1.0, arrow_length_ratio=0.1, color='m') #length = mag_ri[i]
            uni_ri[i] = ri[i]/mag_ri[i]
            vec_E[i] = (ke*q[i]/mag_ri[i]**2)*uni_ri[i]
            i += 1
        vec_Ep = np.array([sum(vec_E[:,0]), sum(vec_E[:,1]), sum(vec_E[:,2])])
        ax.quiver3D(rp[0], rp[1], rp[2], vec_Ep[0], vec_Ep[1], vec_Ep[2], pivot='tail', length = 1, color='c', arrow_length_ratio=0.3, normalize=True)
        mag_Ep = np.sqrt(sum(vec_Ep**2))
        
        mag_rp = np.sqrt(rp[0]**2+rp[1]**2+rp[2]**2)
        arrows = np.array([[0, 0, 0, 2*mag_rp, 0, 0], [0, 0, 0, 0, 2*mag_rp, 0], [0, 0, 0, 0, 0, 2*mag_rp]])
        X, Y, Z, U, V, W = zip(*arrows)
        ax.quiver3D(X, Y, Z, U, V, W, pivot='tail', length = 1.0, color='k', arrow_length_ratio=0.1) #length = 2*mag_rp
        ax.set_xlim([-rq.max()-rp.max(), rq.max()+rp.max()])
        ax.set_ylim([-rq.max()-rp.max(), rq.max()+rp.max()])
        ax.set_zlim([-rq.max()-rp.max(), rq.max()+rp.max()])
        ax.set_xlabel('x')
        ax.set_ylabel('y')
        ax.set_zlabel('z')
        ax.set_title('$E_p = $'+str(vec_Ep[0])+' $i$ +'+str(vec_Ep[1])+' $j$ +'+str(vec_Ep[2])+' $k$'+str( )+' $[V/m]$')
        plt.show()
    return q, rq, ri, mag_ri, uni_ri, vec_E, vec_Ep, mag_Ep

q, rq, ri, mag_ri, uni_ri, vec_E, vec_Ep, mag_Ep = field_punctual_charges(rp=rp, n=nq)
print('\n', 'Ep = '+str(vec_Ep[0])+' i +'+str(vec_Ep[1])+' j +'+str(vec_Ep[2])+' k'+str( )+' [V/m]')
print('\n', 'Ep = '+ str(mag_Ep) + ' [V/m]')
